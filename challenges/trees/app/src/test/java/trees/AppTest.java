/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package trees;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import trees.KTree.KTree;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {
    @Test void appHasAGreeting() {
        App classUnderTest = new App();
        assertNotNull(classUnderTest.getGreeting(), "app should have a greeting");
    }

    // Can successfully instantiate an empty tree
    @DisplayName("instantiate an empty tree")
    @Test void instantiateEmptyTree(){
        BinarySearchTree<Integer> bst = new BinarySearchTree<>();
        assertNotNull(bst);
    }


    @DisplayName("instantiate a tree with a single root node")
    @Test void instantiateTreeWithRootOnly(){
        BinarySearchTree<Integer> bst = new BinarySearchTree<>();
        bst.Add(57);
        assertEquals(57,bst.getRoot().getData());
    }


    @DisplayName("add a left child and right child to a single root node")
    @Test void addLeftAndRighChildToSingleRoot(){
        BinarySearchTree<Integer> bst = new BinarySearchTree<>();
        bst.Add(10);
        bst.Add(5);
        bst.Add(15);
        assertEquals(10,bst.getRoot().getData());
        assertEquals(5,bst.getRoot().getLeftNode().getData());
        assertEquals(15,bst.getRoot().getRightNode().getData());
    }

    @DisplayName("Testing the traversals")
    @Test void traverseBinarySearchTree(){
        BinarySearchTree<Integer> bst = new BinarySearchTree<>();
        bst.Add(8);
        bst.Add(3);
        bst.Add(10);
        bst.Add(1);
        bst.Add(6);
        bst.Add(14);

        // preOrder traverse
        assertEquals("[8, 3, 1, 6, 10, 14]",bst.preorderTraversal().toString());

        // inOrder traverse
        assertEquals("[1, 3, 6, 8, 10, 14]",bst.inorderTraversal().toString());

        // postOrder traverse
        assertEquals("[1, 6, 3, 14, 10, 8]",bst.postorderTraversal().toString());
    }

    @DisplayName("Testing containing")
    @Test void containBinarySearchTree(){
        BinarySearchTree<Integer> bst = new BinarySearchTree<>();
        bst.Add(8);
        bst.Add(3);
        bst.Add(10);
        bst.Add(1);
        bst.Add(6);
        bst.Add(14);

        assertTrue(bst.Contains(1));
        assertFalse(bst.Contains(7));
        assertTrue(bst.Contains(14));
        assertFalse(bst.Contains(100));
    }

    // Test max method

    @Test
    public void maxValueTest(){
        BinarySearchTree<Integer> binarySearchTree = new BinarySearchTree<Integer>();

        binarySearchTree.setRoot(new BinaryNode<>(7));
        assertEquals(7,binarySearchTree.FindMax());

        binarySearchTree.getRoot().setLeftNode(new BinaryNode<>(9));
        binarySearchTree.getRoot().setRightNode(new BinaryNode<>(11));
        assertEquals(11,binarySearchTree.FindMax());

        binarySearchTree.getRoot().getLeftNode().setLeftNode(new BinaryNode<>(13));
        binarySearchTree.getRoot().getLeftNode().setRightNode(new BinaryNode<>((1)));
        assertEquals(13,binarySearchTree.FindMax());
    }

    //    Test for empty tree
    @Test
    public void testMaxEmptyTree() {
        Assertions.assertThrows(NullPointerException.class, () -> {
            BinarySearchTree<Integer> binarySearchTree = new BinarySearchTree<Integer>();
            binarySearchTree.FindMax();
        });
    }

    @Test
    public void testbreadthFirst() throws Exception {
        BinarySearchTree<Integer> binarySearchTree = new BinarySearchTree<Integer>();

        // adds nodes to the tree
        binarySearchTree.setRoot(new BinaryNode<>(1));
        binarySearchTree.getRoot().setLeftNode(new BinaryNode(2));
        binarySearchTree.getRoot().setRightNode(new BinaryNode(3));
        binarySearchTree.getRoot().getRightNode().setLeftNode(new BinaryNode<>(10));
        binarySearchTree.getRoot().getRightNode().setRightNode(new BinaryNode<>(41));
        binarySearchTree.getRoot().getLeftNode().setLeftNode(new BinaryNode<>(4));
        binarySearchTree.getRoot().getLeftNode().setRightNode(new BinaryNode<>(8));

        assertEquals("[1, 2, 3, 4, 8, 10, 41]","[1, 2, 3, 4, 8, 10, 41]","" + binarySearchTree.breadthFirst(binarySearchTree));
    }

    //        <<< Code Challenge 18 >>>

    @Test
    public void kTreeFizzBuzzTest(){

        KTree kTree = new KTree(2);

        kTree.add(1);
        kTree.add(2);
        assertEquals("K-ary tree (K=2): {\n" +
                " root={ value = 1 Children: [\n" +
                " child: { value = 2 Children: []]\n" +
                "nodes=2}",kTree.fizzBuzzTree(kTree).toString() );

        kTree.add(3);
        assertEquals("K-ary tree (K=2): {\n" +
                " root={ value = 1 Children: [\n" +
                " child: { value = 2 Children: []\n" +
                " child: { value = Fizz Children: []]\n" +
                "nodes=3}", kTree.fizzBuzzTree(kTree).toString());

        kTree.add(5);
        assertEquals("K-ary tree (K=2): {\n" +
                " root={ value = 1 Children: [\n" +
                " child: { value = 2 Children: [\n" +
                " child: { value = Buzz Children: []]\n" +
                " child: { value = Fizz Children: []]\n" +
                "nodes=4}", kTree.fizzBuzzTree(kTree).toString());

        kTree.add(15);
        assertEquals("K-ary tree (K=2): {\n" +
                " root={ value = 1 Children: [\n" +
                " child: { value = 2 Children: [\n" +
                " child: { value = Buzz Children: []\n" +
                " child: { value = FizzBuzz Children: []]\n" +
                " child: { value = Fizz Children: []]\n" +
                "nodes=5}", kTree.fizzBuzzTree(kTree).toString());

    }

}
